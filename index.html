<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />

    <title>Crispoparte V13 - √Åudio + Salvar + Molduras</title>

    <style>
        :root {
            --accent: #25D366;
            --primary: #FF5722;
            --record: #ff0000;
            --bg-overlay: rgba(0, 0, 0, 0.65);
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            background: #000;
            color: #fff;
            overflow: hidden;
            width: 100vw;
            height: 100dvh;
            font-family: sans-serif;
        }

        .frame {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
        }

        .stage {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #111;
        }

        video,
        #molduraPreview,
        #canvasPreview,
        #videoPreview {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        video.mirrored {
            transform: scaleX(-1);
        }

        #molduraPreview {
            pointer-events: none;
            z-index: 5;
        }

        #canvasPreview,
        #videoPreview {
            display: none;
            z-index: 6;
        }

        /* UI */

        .ui-layer {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 20;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
        }

        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: auto;
        }

        .timer-badge {
            background: red;
            padding: 5px 12px;
            border-radius: 12px;
            display: none;
            font-size: 16px;
            font-weight: bold;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }

            100% {
                opacity: 1;
            }
        }

        .controls-bottom {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            pointer-events: auto;
        }

        .mode-switch {
            display: flex;
            background: rgba(0, 0, 0, 0.5);
            padding: 4px;
            border-radius: 20px;
        }

        .mode-btn {
            padding: 8px 20px;
            border-radius: 16px;
            border: none;
            font-weight: bold;
            background: transparent;
            color: #ccc;
        }

        .mode-btn.active {
            background: white;
            color: black;
        }

        .frame-selector {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 10px 16px;
            border-radius: 20px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: var(--bg-overlay);
            color: white;
            cursor: pointer;
        }

        .btn.active {
            border-color: var(--accent);
            color: var(--accent);
        }

        /* Capture Button */

        #captureBtn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 4px solid #fff;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #captureBtn.recording {
            border-color: red;
            background: rgba(255, 0, 0, 0.5);
        }

        .stop-icon {
            width: 28px;
            height: 28px;
            background: red;
            display: none;
        }

        #captureBtn.recording .stop-icon {
            display: block;
        }

        #captureBtn.recording .cam-icon {
            display: none;
        }

        /* Start Screen */

        #startScreen {
            position: absolute;
            inset: 0;
            background: black;
            z-index: 50;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
        }

        /* Result */

        #postCaptureActions {
            display: none;
            flex-direction: column;
            gap: 15px;
            width: 100%;
            max-width: 300px;
        }

        .action-btn {
            padding: 16px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
        }

        .btn-save {
            background: var(--accent);
            color: white;
        }

        .btn-new {
            background: #555;
            color: white;
        }

        .flash {
            position: absolute;
            inset: 0;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 10;
            transition: 0.1s;
        }
    </style>
</head>

<body>

    <div class="frame">
        <div class="stage" id="stage">

            <video id="camera" autoplay playsinline muted></video>
            <canvas id="canvasPreview"></canvas>
            <video id="videoPreview" playsinline controls></video>
            <img id="molduraPreview" />

            <div class="flash" id="flash"></div>

            <div class="ui-layer" id="cameraUI" style="display:none;">
                <div class="top-bar">
                    <button id="switchBtn" class="btn">üîÑ Trocar</button>
                    <div id="recordingTimer" class="timer-badge">00:00</div>
                </div>

                <div class="controls-bottom">

                    <div class="mode-switch">
                        <button class="mode-btn active" id="modePhoto">FOTO</button>
                        <button class="mode-btn" id="modeVideo">V√çDEO</button>
                    </div>

                    <div class="frame-selector">
                        <button class="btn active" id="m1Btn">1</button>
                        <button class="btn" id="m2Btn">2</button>
                    </div>

                    <button id="captureBtn">
                        <svg class="cam-icon" width="34" height="34" viewBox="0 0 24 24">
                            <path
                                d="M12 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3zM20 5h-3.17L15 3H9L7.17 5H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2z" />
                        </svg>
                        <div class="stop-icon"></div>
                    </button>

                </div>
            </div>

            <div class="ui-layer" id="resultUI" style="display:none; justify-content:flex-end; align-items:center;">
                <div id="postCaptureActions">
                    <a id="downloadBtn" class="action-btn btn-save">üì• Salvar / Baixar</a>
                    <button id="shareManualBtn" class="action-btn btn-new">üì± Compartilhar</button>
                </div>
            </div>

        </div>
    </div>

    <div id="startScreen">
        <h2>C√¢mera Crispoparte</h2>
        <p style="color:#bbb;">Permita c√¢mera e microfone</p>
        <button id="startBtn" style="padding:18px 30px; font-size:20px; border:none; border-radius:40px; background:#FF5722; color:white;">INICIAR</button>
        <p id="errorMsg" style="color:red; font-size:13px;"></p>
    </div>

    <canvas id="canvasFinal" style="display:none;"></canvas>

    <script>

        /* CONFIGURA√á√ïES */
        const MOLDURAS = {
            m1: "moldura1.png",
            m2: "moldura2.png"
        };

        let currentMolduraUrl = MOLDURAS.m1;
        let usingFrontCamera = true;
        let currentMode = "photo";

        let stream = null;
        let mediaRecorder = null;
        let isRecording = false;
        let recordedChunks = [];
        let animationFrameId = null;

        let finalMimeType = null;
        let finalFileExtension = null;

        let currentBlob = null;
        let currentBlobUrl = null;
        let currentFileName = null;
        let currentFileType = null;


        /* DOM */
        const video = document.getElementById("camera");
        const videoPreview = document.getElementById("videoPreview");
        const canvasPreview = document.getElementById("canvasPreview");
        const canvasFinal = document.getElementById("canvasFinal");
        const ctxFinal = canvasFinal.getContext("2d");

        const molduraPreview = document.getElementById("molduraPreview");

        const startScreen = document.getElementById("startScreen");
        const cameraUI = document.getElementById("cameraUI");
        const resultUI = document.getElementById("resultUI");

        const captureBtn = document.getElementById("captureBtn");
        const recordingTimer = document.getElementById("recordingTimer");

        const downloadBtn = document.getElementById("downloadBtn");
        const shareManualBtn = document.getElementById("shareManualBtn");

        const errorMsg = document.getElementById("errorMsg");


        /* BOT√ïES */
        document.getElementById("startBtn").addEventListener("click", () => initCamera(true));
        document.getElementById("switchBtn").addEventListener("click", switchCamera);

        document.getElementById("modePhoto").addEventListener("click", () => setMode("photo"));
        document.getElementById("modeVideo").addEventListener("click", () => setMode("video"));

        document.getElementById("m1Btn").addEventListener("click", () => setMoldura("m1"));
        document.getElementById("m2Btn").addEventListener("click", () => setMoldura("m2"));

        captureBtn.addEventListener("click", () => {
            if (currentMode === "photo") takePhoto();
            else isRecording ? stopRecording() : startRecording();
        });

        downloadBtn.addEventListener("click", () => {
            if (!currentBlobUrl) {
                alert("O arquivo ainda n√£o est√° pronto!");
            }
        });


        /* ----- FUN√á√ïES PRINCIPAIS ----- */

        function setMode(mode) {
            currentMode = mode;

            document.getElementById("modePhoto").classList.toggle("active", mode === "photo");
            document.getElementById("modeVideo").classList.toggle("active", mode === "video");

            captureBtn.style.borderColor = mode === "video" ? "red" : "white";
        }


        function setMoldura(key) {
            document.getElementById("m1Btn").classList.toggle("active", key === "m1");
            document.getElementById("m2Btn").classList.toggle("active", key === "m2");

            currentMolduraUrl = MOLDURAS[key];
            molduraPreview.src = currentMolduraUrl;
        }


        async function initCamera(withAudio = true) {

            if (stream) {
                stream.getTracks().forEach(t => t.stop());
                stream = null;
            }

            errorMsg.innerText = "Solicitando permiss√µes...";

            let constraints = {
                video: {
                    facingMode: usingFrontCamera ? "user" : "environment"
                },
                audio: withAudio
            };

            try {
                stream = await navigator.mediaDevices.getUserMedia(constraints);
            } catch (e) {
                if (withAudio) return initCamera(false);
                errorMsg.innerText = "ERRO: N√£o foi poss√≠vel ativar c√¢mera/microfone.";
                return;
            }

            video.srcObject = stream;

            if (usingFrontCamera) video.classList.add("mirrored");
            else video.classList.remove("mirrored");

            video.onloadedmetadata = () => {
                video.play();
                startScreen.style.display = "none";
                cameraUI.style.display = "flex";
            };
        }


        async function switchCamera() {
            usingFrontCamera = !usingFrontCamera;
            await initCamera(true);
        }



        /* ----- FOTO ----- */

        function takePhoto() {

            canvasFinal.width = 1080;
            canvasFinal.height = 1920;

            drawVideoToCanvas(ctxFinal, 1080, 1920);

            const img = new Image();
            img.onload = () => {
                ctxFinal.drawImage(img, 0, 0, 1080, 1920);

                canvasFinal.toBlob(blob => {
                    showResult("image", blob);
                }, "image/png");
            };
            img.src = currentMolduraUrl;

            flash();
        }



        /* ----- V√çDEO ----- */

        function startRecording() {

            isRecording = true;
            captureBtn.classList.add("recording");
            recordedChunks = [];

            recordingTimer.style.display = "block";
            recordingStart = Date.now();

            canvasFinal.width = 720;
            canvasFinal.height = 1280;

            const loop = () => {
                if (!isRecording) return;
                drawVideoToCanvas(ctxFinal, 720, 1280);

                const frame = new Image();
                frame.src = currentMolduraUrl;
                ctxFinal.drawImage(frame, 0, 0, 720, 1280);

                updateTimer();
                animationFrameId = requestAnimationFrame(loop);
            };
            loop();

            const canvasStream = canvasFinal.captureStream(30);

            let audioTrack = null;
            try {
                audioTrack = stream.getAudioTracks()[0];
                canvasStream.addTrack(audioTrack);
            } catch (e) { }

            const mimeList = [
                "video/webm;codecs=vp9",
                "video/webm;codecs=vp8",
                "video/webm",
            ];

            let selected = mimeList.find(m => MediaRecorder.isTypeSupported(m));

            finalMimeType = selected;
            finalFileExtension = "webm";

            mediaRecorder = new MediaRecorder(canvasStream, { mimeType: selected });

            mediaRecorder.ondataavailable = e => {
                if (e.data.size > 0) recordedChunks.push(e.data);
            };

            mediaRecorder.onstop = finishVideo;

            mediaRecorder.start();
        }


        function stopRecording() {
            isRecording = false;
            captureBtn.classList.remove("recording");

            recordingTimer.style.display = "none";
            recordingTimer.innerText = "00:00";

            cancelAnimationFrame(animationFrameId);

            mediaRecorder.stop();
        }


        function finishVideo() {

            const blob = new Blob(recordedChunks, { type: finalMimeType });

            const url = URL.createObjectURL(blob);
            videoPreview.src = url;

            showResult("video", blob);
        }



        /* ----- RESULTADO (FOTO + V√çDEO) ----- */

        function showResult(type, blob) {

            video.style.display = "none";
            molduraPreview.style.display = "none";
            cameraUI.style.display = "none";
            resultUI.style.display = "flex";

            document.getElementById("postCaptureActions").style.display = "flex";

            const time = Date.now();

            currentBlob = blob;
            currentFileType = type;

            currentFileName =
                type === "image"
                    ? `foto_${time}.png`
                    : `video_${time}.${finalFileExtension}`;

            const fallbackUrl = URL.createObjectURL(blob);
            currentBlobUrl = fallbackUrl;


            /* DOWNLOAD AUTOM√ÅTICO + FALLBACK */
            try {
                const a = document.createElement("a");
                a.href = fallbackUrl;
                a.download = currentFileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            } catch (e) {
                console.warn("Download autom√°tico falhou. Usando fallback.", e);
            }

            downloadBtn.href = fallbackUrl;
            downloadBtn.download = currentFileName;
            downloadBtn.innerText = "üì• Salvar / Baixar";

            canvasPreview.style.display = type === "image" ? "block" : "none";
            videoPreview.style.display = type === "video" ? "block" : "none";

            if (type === "image") {
                const ctxPrev = canvasPreview.getContext("2d");
                canvasPreview.width = stage.clientWidth;
                canvasPreview.height = stage.clientHeight;
                ctxPrev.drawImage(canvasFinal, 0, 0, canvasPreview.width, canvasPreview.height);
            }
        }



        /* ----- AUXILIARES ----- */

        function drawVideoToCanvas(ctx, w, h) {

            const vw = video.videoWidth;
            const vh = video.videoHeight;
            if (!vw || !vh) return;

            const videoRatio = vw / vh;
            const canvasRatio = w / h;

            let dw, dh, dx, dy;

            if (videoRatio > canvasRatio) {
                dh = h;
                dw = h * videoRatio;
                dx = (w - dw) / 2;
                dy = 0;
            } else {
                dw = w;
                dh = w / videoRatio;
                dx = 0;
                dy = (h - dh) / 2;
            }

            if (usingFrontCamera) {
                ctx.save();
                ctx.scale(-1, 1);
                ctx.drawImage(video, -dx - dw, dy, dw, dh);
                ctx.restore();
            } else {
                ctx.drawImage(video, dx, dy, dw, dh);
            }
        }


        function updateTimer() {
            const sec = Math.floor((Date.now() - recordingStart) / 1000);
            const m = String(Math.floor(sec / 60)).padStart(2, "0");
            const s = String(sec % 60).padStart(2, "0");
            recordingTimer.innerText = `${m}:${s}`;
        }

        function flash() {
            const f = document.getElementById("flash");
            f.style.opacity = 1;
            setTimeout(() => f.style.opacity = 0, 150);
        }

    </script>

</body>

</html>
