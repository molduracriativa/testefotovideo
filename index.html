<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Crispoparte V12 - √Åudio + V√≠deo + Moldura</title>
  <style>
    :root {
      --accent: #25D366;
      --primary: #FF5722;
      --record: #ff0000;
      --bg-overlay: rgba(0, 0, 0, 0.65);
    }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    body { margin: 0; background: #000; color: #fff; overflow: hidden; width: 100vw; height: 100dvh; font-family: sans-serif; }
    .frame { position: relative; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: #000; }
    .stage { position: relative; width: 100%; height: 100%; overflow: hidden; background: #111; }
    video, #molduraPreview, #canvasPreview, #videoPreview { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
    video { transform: scaleX(1); transition: transform 0.3s; }
    video.mirrored { transform: scaleX(-1); }
    #molduraPreview { pointer-events: none; z-index: 5; }
    #canvasPreview, #videoPreview { display: none; z-index: 6; background: #000; }
    .ui-layer { position: absolute; inset: 0; pointer-events: none; z-index: 20; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; }
    .top-bar { display: flex; justify-content: space-between; align-items: flex-start; pointer-events: auto; }
    .timer-badge { background: red; color: white; padding: 5px 12px; border-radius: 12px; font-weight: bold; font-size: 16px; display: none; animation: pulse 1s infinite; }
    @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }
    .controls-bottom { display: flex; flex-direction: column; align-items: center; gap: 15px; pointer-events: auto; padding-bottom: 20px; }
    .mode-switch { display: flex; background: rgba(0,0,0,0.5); border-radius: 20px; padding: 4px; backdrop-filter: blur(4px); }
    .mode-btn { padding: 8px 20px; border-radius: 16px; border: none; background: transparent; color: #ccc; font-weight: 600; cursor: pointer; }
    .mode-btn.active { background: #fff; color: #000; }
    .btn { padding: 10px 16px; font-size: 14px; font-weight: 600; border: 2px solid rgba(255,255,255,0.3); border-radius: 20px; background: var(--bg-overlay); color: #fff; cursor: pointer; backdrop-filter: blur(4px); }
    .btn.active { border-color: var(--accent); background: rgba(37, 211, 102, 0.2); color: var(--accent); }
    .frame-selector { display: flex; gap: 10px; }
    #captureBtn { width: 80px; height: 80px; border-radius: 50%; border: 4px solid #fff; background: rgba(255,255,255,0.2); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
    #captureBtn:active { transform: scale(0.95); }
    #captureBtn svg { width: 36px; height: 36px; fill: #fff; }
    #captureBtn.recording { border-color: var(--record); background: rgba(255, 0, 0, 0.5); }
    #captureBtn.recording svg { fill: var(--record); }
    #captureBtn .stop-icon { display: none; width: 30px; height: 30px; background: var(--record); border-radius: 4px; }
    #captureBtn.recording .stop-icon { display: block; }
    #captureBtn.recording .cam-icon { display: none; }
    #startScreen { position: absolute; inset: 0; background: #000; z-index: 50; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 20px; text-align: center; }
    #startBtn { padding: 18px 32px; font-size: 20px; background: var(--primary); color: white; border: none; border-radius: 50px; cursor: pointer; }
    #postCaptureActions { display: none; flex-direction: column; gap: 12px; width: 100%; max-width: 300px; pointer-events: auto; }
    .action-btn { width: 100%; padding: 14px; border-radius: 12px; border: none; font-size: 16px; font-weight: bold; cursor: pointer; text-align: center; text-decoration: none; display: inline-block; }
    .btn-save { background: var(--accent); color: #fff; }
    .btn-new { background: #555; color: #fff; }
    .flash { position: absolute; inset: 0; background: #fff; opacity: 0; pointer-events: none; z-index: 10; transition: opacity 0.1s; }
    .status { position: absolute; bottom: 18px; left: 18px; z-index: 60; font-size: 13px; color: #ccc; background: rgba(0,0,0,0.4); padding: 6px 10px; border-radius: 10px; pointer-events: none; }
  </style>
</head>
<body>

  <div class="frame">
    <div class="stage" id="stage">
      <video id="camera" autoplay playsinline muted></video>
      <canvas id="canvasPreview"></canvas> 
      <video id="videoPreview" playsinline controls></video>
      <img id="molduraPreview" alt="" src="" />
      <div class="flash" id="flash"></div>

      <div class="ui-layer" id="cameraUI" style="display: none;">
        <div class="top-bar">
          <button class="btn" id="switchBtn">üîÑ Trocar</button>
          <div id="recordingTimer" class="timer-badge">00:00</div>
        </div>

        <div class="controls-bottom">
          <div class="mode-switch">
             <button class="mode-btn active" id="modePhoto">FOTO</button>
             <button class="mode-btn" id="modeVideo">V√çDEO</button>
          </div>

          <div class="frame-selector">
            <button class="btn active" id="m1Btn">1</button>
            <button class="btn" id="m2Btn">2</button>
          </div>

          <button id="captureBtn">
            <svg class="cam-icon" viewBox="0 0 24 24"><path d="M12 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/><path d="M20 5h-3.17L15 3H9L7.17 5H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 14H4V7h16v12z"/></svg>
            <div class="stop-icon"></div>
          </button>
        </div>
      </div>

      <div class="ui-layer" id="resultUI" style="display: none; justify-content: flex-end; align-items: center;">
        <div id="postCaptureActions">
          <a id="downloadBtn" class="action-btn btn-save">üì• Baixar / Salvar</a>
          <button id="shareManualBtn" class="action-btn btn-new">üì± Compartilhar no WhatsApp</button>
        </div>
      </div>

      <div class="status" id="statusMsg">Aguardando</div>
    </div>
  </div>

  <div id="startScreen">
    <h2 style="margin-bottom:0">C√¢mera Crispoparte</h2>
    <p style="color:#aaa; margin-top:5px">Permita c√¢mera e microfone</p>
    <button id="startBtn">INICIAR</button>
    <p id="errorMsg" style="color:red; font-size:12px; margin-top: 10px;"></p>
  </div>

  <canvas id="canvasFinal" style="display: none;"></canvas>

  <script>
    /*
      INSTRU√á√ïES IMPORTANTES:
      - Defina MERGE_SERVER para o endpoint do seu servidor Node/FFmpeg (ex: 'http://192.168.0.10:4000/merge').
      - Se n√£o quiser usar servidor, deixe vazio ('') ‚Äî o cliente tentar√° gravar mixedStream e, se n√£o for poss√≠vel,
        oferecer√° arquivos separados (v√≠deo.webm + audio.webm) para download.
    */
    const MERGE_SERVER = ''; // <-- coloque aqui: 'http://SEU_SERVIDOR:4000/merge' se quiser merge no servidor

    // --- Config ---
    const MOLDURAS = { 'm1': 'moldura1.png', 'm2': 'moldura2.png' };
    let currentMolduraUrl = MOLDURAS['m1'];
    let currentMolduraImg = new Image();
    currentMolduraImg.crossOrigin = "anonymous";
    currentMolduraImg.src = currentMolduraUrl;

    let usingFrontCamera = true;
    let stream = null;             // camera + mic (se dispon√≠vel)
    let currentMode = 'photo';
    let isRecording = false;

    let mediaRecorder = null;     // single mixed recorder when possible
    let videoRecorder = null;     // fallback video-only recorder
    let audioRecorder = null;     // fallback audio-only recorder

    let recordedChunks = [];      // for single mixed file
    let recordedVideoChunks = []; // fallback video
    let recordedAudioChunks = []; // fallback audio

    let recordingStartTime = 0;
    let animationFrameId = null;
    let canvasStream = null;

    let finalMimeType = null;
    let finalFileExtension = null;

    // file state
    let currentBlob = null;
    let currentBlobUrl = null;
    let currentFileName = null;
    let currentFileType = null;

    // --- DOM Elements ---
    const video = document.getElementById('camera');
    const stage = document.getElementById('stage');
    const canvasPreview = document.getElementById('canvasPreview'); // this canvas used visually sometimes
    const videoPreview = document.getElementById('videoPreview');
    const molduraPreview = document.getElementById('molduraPreview');
    const canvasFinal = document.getElementById('canvasFinal');
    const ctxFinal = canvasFinal.getContext('2d', { alpha: false });

    const startScreen = document.getElementById('startScreen');
    const cameraUI = document.getElementById('cameraUI');
    const resultUI = document.getElementById('resultUI');
    const captureBtn = document.getElementById('captureBtn');
    const recordingTimer = document.getElementById('recordingTimer');
    const errorMsg = document.getElementById('errorMsg');
    const downloadBtn = document.getElementById('downloadBtn');
    const shareManualBtn = document.getElementById('shareManualBtn');
    const statusMsg = document.getElementById('statusMsg');

    // --- Events ---
    setMoldura(document.getElementById('m1Btn'), 'm1');
    document.getElementById('startBtn').addEventListener('click', () => initCamera(true));
    document.getElementById('switchBtn').addEventListener('click', switchCamera);
    document.getElementById('m1Btn').addEventListener('click', (e) => setMoldura(e.target, 'm1'));
    document.getElementById('m2Btn').addEventListener('click', (e) => setMoldura(e.target, 'm2'));
    document.getElementById('modePhoto').addEventListener('click', () => setMode('photo'));
    document.getElementById('modeVideo').addEventListener('click', () => setMode('video'));

    captureBtn.addEventListener('click', () => {
        if (currentMode === 'photo') takePhoto();
        else { if (!isRecording) startRecording(); else stopRecording(); }
    });

    shareManualBtn.addEventListener('click', showShareInstructions);
    downloadBtn.addEventListener('click', (e) => {
        if (!downloadBtn.href || downloadBtn.href.includes('#')) {
            e.preventDefault();
            alert("Aguarde a finaliza√ß√£o do processamento antes de clicar.");
        }
    });

    // --- Helpers ---
    function setStatus(s){ statusMsg.innerText = s; }
    function log(...args){ console.log('[crispoparte]', ...args); }

    // --- Moldura / UI ---
    function setMode(mode) {
        currentMode = mode;
        document.getElementById('modePhoto').className = mode === 'photo' ? 'mode-btn active' : 'mode-btn';
        document.getElementById('modeVideo').className = mode === 'video' ? 'mode-btn active' : 'mode-btn';
        captureBtn.style.borderColor = mode === 'video' ? '#ff0000' : '#fff';
    }

    function setMoldura(btn, key) {
      document.querySelectorAll('.frame-selector .btn').forEach(b => b.classList.remove('active'));
      if(btn) btn.classList.add('active');
      currentMolduraUrl = MOLDURAS[key];
      molduraPreview.src = currentMolduraUrl;
      currentMolduraImg = new Image();
      currentMolduraImg.crossOrigin = "anonymous";
      currentMolduraImg.src = currentMolduraUrl;
    }

    // --- Camera init ---
    async function initCamera(tryAudio = true) {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
      }
      setStatus("Solicitando permiss√µes...");
      errorMsg.innerText = "Solicitando permiss√µes...";

      const currentFacingMode = usingFrontCamera ? 'user' : 'environment';
      const constraintsList = [
        { video: { facingMode: currentFacingMode, width: { ideal: 1280 }, height: { ideal: 720 } } },
        { video: { facingMode: currentFacingMode, width: { ideal: 640 }, height: { ideal: 480 } } },
        { video: { facingMode: currentFacingMode } }
      ];

      for (const videoConstraints of constraintsList) {
        let constraints = { ...videoConstraints };
        if (tryAudio) constraints.audio = { echoCancellation: true, noiseSuppression: true };

        try {
          stream = await navigator.mediaDevices.getUserMedia(constraints);
          handleStreamSuccess(stream);
          return;
        } catch (err) {
          console.warn('Tentativa falhou com restri√ß√µes:', constraints, 'Erro:', err && err.name);
        }
      }

      if (tryAudio) {
           setStatus("Erro no √°udio. Tentando iniciar sem microfone...");
           errorMsg.innerText = "Erro no √°udio. Tentando iniciar sem microfone...";
           await initCamera(false);
      } else {
           const errMsg = `FALHA CR√çTICA! A c√¢mera e o √°udio n√£o puderam ser inicializados.`;
           errorMsg.innerText = errMsg;
           setStatus(errMsg);
           alert(errMsg);
      }
    }

    function handleStreamSuccess(newStream) {
        stream = newStream;
        video.srcObject = stream;
        if (usingFrontCamera) video.classList.add('mirrored');
        else video.classList.remove('mirrored');

        video.onloadedmetadata = () => {
          video.play().catch(()=>{});
          startScreen.style.display = 'none';
          cameraUI.style.display = 'flex';
          setStatus('Pronto');
          errorMsg.innerText = "";
        };
    }

    async function switchCamera() {
      if (isRecording) stopRecording();
      usingFrontCamera = !usingFrontCamera;
      await new Promise(resolve => setTimeout(resolve, 600));
      await initCamera(true);
    }

    // --- Photo ---
    async function takePhoto() {
      flashEffect();
      canvasFinal.width = 1080; canvasFinal.height = 1920;
      drawVideoToCanvas(ctxFinal, 1080, 1920);
      await drawImageLayer(ctxFinal, currentMolduraUrl, 1080, 1920);

      const ctxPrev = canvasPreview.getContext('2d');
      canvasPreview.width = stage.clientWidth; canvasPreview.height = stage.clientHeight;
      ctxPrev.drawImage(canvasFinal, 0, 0, canvasPreview.width, canvasPreview.height);

      canvasFinal.toBlob(blob => { showResult('image', blob); }, 'image/png');
    }

    // --- Recording (audio + canvas) ---
    async function startRecording() {
        isRecording = true;
        captureBtn.classList.add('recording');
        recordingTimer.style.display = 'block';
        recordingStartTime = Date.now();
        recordedChunks = [];
        recordedVideoChunks = [];
        recordedAudioChunks = [];
        finalMimeType = null;
        finalFileExtension = null;

        canvasFinal.width = 720; canvasFinal.height = 1280;

        // loop draw
        const loop = () => {
            if (!isRecording) return;
            drawVideoToCanvas(ctxFinal, 720, 1280);
            if (currentMolduraImg && currentMolduraImg.complete) ctxFinal.drawImage(currentMolduraImg, 0, 0, 720, 1280);
            updateTimer();
            animationFrameId = requestAnimationFrame(loop);
        };
        loop();

        // capture canvas stream (video)
        canvasStream = canvasFinal.captureStream(30);

        // try to include mic audio tracks
        const audioTracks = stream ? stream.getAudioTracks() : [];
        let mixedStream;
        if (audioTracks && audioTracks.length > 0) {
            // Attempt to use original audio tracks + canvas video
            mixedStream = new MediaStream([
              ...canvasStream.getVideoTracks(),
              ...audioTracks
            ]);
        } else {
            mixedStream = canvasStream;
            console.warn('Nenhuma faixa de √°udio detectada no stream principal');
        }

        // choose preferred mime
        const preferredMimeTypes = [
            'video/webm;codecs=vp9,opus',
            'video/webm;codecs=vp8,opus',
            'video/webm',
            'video/mp4'
        ];
        let selectedMimeType = null;
        for (const m of preferredMimeTypes) {
            try {
              if (m && MediaRecorder.isTypeSupported(m)) {
                  selectedMimeType = m;
                  break;
              }
            } catch(e){}
        }
        // fallback
        if (!selectedMimeType) selectedMimeType = '';

        finalMimeType = selectedMimeType || 'video/webm';
        finalFileExtension = finalMimeType.includes('mp4') ? 'mp4' : 'webm';

        // Try single MediaRecorder with mixed stream
        let startedSingle = false;
        try {
            mediaRecorder = selectedMimeType ? new MediaRecorder(mixedStream, { mimeType: selectedMimeType }) : new MediaRecorder(mixedStream);
            mediaRecorder.ondataavailable = e => { if (e.data && e.data.size) recordedChunks.push(e.data); };
            mediaRecorder.onstop = () => {
              // single mixed file ready
              finishVideoSingle();
            };
            mediaRecorder.onerror = (e) => console.error('mediaRecorder error', e);
            mediaRecorder.start(1000);
            startedSingle = true;
            setStatus('Gravando (single stream) ...');
            log('MediaRecorder started (single) mime:', selectedMimeType);
        } catch (err) {
            console.warn('Falha ao iniciar MediaRecorder single (mixedStream):', err);
            startedSingle = false;
        }

        if (!startedSingle) {
          // Fallback: record video and audio separately
          setStatus('Fallback: ser√° gravado v√≠deo e √°udio separados (merge posterior)');
          try {
            const vmime = preferredMimeTypes.find(m => { try { return MediaRecorder.isTypeSupported(m); } catch(e){return false;} }) || '';
            videoRecorder = vmime ? new MediaRecorder(canvasStream, { mimeType: vmime }) : new MediaRecorder(canvasStream);
            videoRecorder.ondataavailable = e => { if (e.data && e.data.size) recordedVideoChunks.push(e.data); };

            // audio recorder from mic (if available)
            if (audioTracks && audioTracks.length > 0) {
              const aStream = new MediaStream(audioTracks.map(t => t.clone ? t.clone() : t));
              // prefer audio/webm;codecs=opus
              let ami = 'audio/webm;codecs=opus';
              try { if (!MediaRecorder.isTypeSupported(ami)) ami = ''; } catch(e){ ami = ''; }
              audioRecorder = ami ? new MediaRecorder(aStream, { mimeType: ami }) : new MediaRecorder(aStream);
              audioRecorder.ondataavailable = e => { if (e.data && e.data.size) recordedAudioChunks.push(e.data); };
            } else {
              audioRecorder = null;
            }

            videoRecorder.onstop = async () => {
              // ensure audio stops as well
              try { if (audioRecorder && audioRecorder.state !== 'inactive') audioRecorder.stop(); } catch(e){}
              await finalizeSeparatedFiles();
            };

            videoRecorder.start(1000);
            if (audioRecorder) audioRecorder.start(1000);

            setStatus('Gravando v√≠deo e √°udio separadamente...');
            log('Fallback recorders started');
          } catch (e) {
            console.error('Erro ao iniciar fallback recorders', e);
            alert('N√£o foi poss√≠vel iniciar a grava√ß√£o neste navegador.');
            stopEverythingAfterError();
          }
        }
    }

    function stopRecording() {
      isRecording = false;
      captureBtn.classList.remove('recording');
      cancelAnimationFrame(animationFrameId);
      try {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
      } catch(e){}
      try {
        if (videoRecorder && videoRecorder.state !== 'inactive') videoRecorder.stop();
      } catch(e){}
      try {
        if (audioRecorder && audioRecorder.state !== 'inactive') audioRecorder.stop();
      } catch(e){}
      recordingTimer.style.display = 'none';
      recordingTimer.innerText = "00:00";
      setStatus('Finalizando grava√ß√£o...');
    }

    // called when single mixed recorder finished
    function finishVideoSingle() {
      const simpleMimeType = finalMimeType ? finalMimeType.split(';')[0] : 'video/webm';
      const blob = new Blob(recordedChunks, { type: simpleMimeType });
      const videoURL = URL.createObjectURL(blob);
      videoPreview.src = videoURL;
      videoPreview.muted = false;
      videoPreview.controls = true;
      videoPreview.style.display = 'block';
      try { videoPreview.play().catch(()=>{}); } catch(e){}
      showResult('video', blob);
      setStatus('Grava√ß√£o finalizada (arquivo √∫nico com √°udio).');
    }

    // finalize when fallback produced separate files
    async function finalizeSeparatedFiles() {
      const vblob = new Blob(recordedVideoChunks, { type: recordedVideoChunks[0]?.type || 'video/webm' });
      const ablob = recordedAudioChunks.length ? new Blob(recordedAudioChunks, { type: recordedAudioChunks[0]?.type || 'audio/webm' }) : null;

      // If no audio recorded -> provide video-only
      if (!ablob) {
        showResult('video', vblob);
        setStatus('Gravado v√≠deo (sem √°udio).');
        return;
      }

      // If MERGE_SERVER configured, upload and get merged MP4
      if (MERGE_SERVER && MERGE_SERVER.trim()) {
        setStatus('Enviando para servidor para mesclar (aguarde)...');
        try {
          const mergedUrl = await uploadAndMergeToServer(vblob, ablob);
          if (mergedUrl) {
            // show result pointing to merged mp4
            currentBlob = await fetch(mergedUrl).then(r => r.blob());
            currentFileType = 'video';
            currentFileName = `video_${Date.now()}.mp4`;
            currentBlobUrl = mergedUrl;
            downloadBtn.href = currentBlobUrl;
            downloadBtn.download = currentFileName;
            downloadBtn.innerText = `‚úÖ Salvo! Clique para Visualizar`;
            setStatus('MP4 mesclado pronto.');
            // set preview
            videoPreview.src = currentBlobUrl;
            videoPreview.style.display = 'block';
            videoPreview.muted = false;
            videoPreview.controls = true;
            try { videoPreview.play().catch(()=>{}); } catch(e){}
            return;
          }
        } catch (e) {
          console.error('uploadAndMergeToServer failed', e);
        }
      }

      // Otherwise, offer separate downloads (video + audio)
      provideSeparateFiles(vblob, ablob);
      setStatus('Gravado (arquivos separados). Fa√ßa merge no servidor/desktop se quiser MP4.');
    }

    function provideSeparateFiles(vblob, ablob) {
      const vurl = URL.createObjectURL(vblob);
      const aurl = URL.createObjectURL(ablob);

      // Video link
      downloadBtn.href = vurl;
      downloadBtn.download = `video_${Date.now()}.webm`;
      downloadBtn.innerText = '‚¨áÔ∏è Baixar v√≠deo (webm)';
      downloadBtn.classList.remove('hidden');
      // create audio link
      let existing = document.getElementById('audioLink');
      if (existing) existing.remove();
      const aLink = document.createElement('a');
      aLink.id = 'audioLink';
      aLink.href = aurl;
      aLink.download = `audio_${Date.now()}.webm`;
      aLink.textContent = '‚¨áÔ∏è Baixar √°udio (webm)';
      aLink.className = 'action-btn btn-new';
      aLink.style.marginTop = '8px';
      downloadBtn.parentNode.appendChild(aLink);
    }

    function stopEverythingAfterError() {
      isRecording = false;
      captureBtn.classList.remove('recording');
      try { if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop(); } catch(e){}
      try { if (videoRecorder && videoRecorder.state !== 'inactive') videoRecorder.stop(); } catch(e){}
      try { if (audioRecorder && audioRecorder.state !== 'inactive') audioRecorder.stop(); } catch(e){}
      recordingTimer.style.display = 'none';
      recordingTimer.innerText = "00:00";
      setStatus('Erro na grava√ß√£o');
      alert('Erro ao iniciar grava√ß√£o neste navegador. Veja console para detalhes.');
    }

    // --- Upload merge to server (client) ---
    async function uploadAndMergeToServer(vblob, ablob) {
      try {
        const form = new FormData();
        form.append('video', vblob, 'video.webm');
        if (ablob) form.append('audio', ablob, 'audio.webm');

        const resp = await fetch(MERGE_SERVER, { method: 'POST', body: form });
        if (!resp.ok) throw new Error('Servidor retornou erro: ' + resp.status);
        const resBlob = await resp.blob();
        const url = URL.createObjectURL(resBlob);

        // place as download link
        return url;
      } catch (e) {
        console.error('uploadAndMergeToServer error', e);
        throw e;
      }
    }

    // --- Result handling & download ---
    function showResult(type, blob = null) {
      video.style.display = 'none';
      molduraPreview.style.display = 'none';
      cameraUI.style.display = 'none';
      resultUI.style.display = 'flex';
      document.getElementById('postCaptureActions').style.display = 'flex';

      const timestamp = Date.now();

      if (currentBlobUrl && currentBlobUrl.startsWith('blob:')) {
          URL.revokeObjectURL(currentBlobUrl);
      }
      currentBlobUrl = null;

      currentBlob = blob;
      currentFileType = type;

      if (type === 'image') {
          canvasPreview.style.display = 'block';
          videoPreview.style.display = 'none';
          currentFileName = `foto_${timestamp}.png`;
      } else {
          canvasPreview.style.display = 'none';
          videoPreview.style.display = 'block';
          const ext = finalFileExtension || 'webm';
          currentFileName = `video_${timestamp}.${ext}`;
          currentBlobUrl = videoPreview.src || URL.createObjectURL(blob);
      }

      // download (attempt save to gallery)
      const tempUrl = URL.createObjectURL(blob);
      const tempLink = document.createElement('a');
      tempLink.style.display = 'none';
      tempLink.href = tempUrl;
      tempLink.download = currentFileName;
      document.body.appendChild(tempLink);
      tempLink.click();
      document.body.removeChild(tempLink);
      URL.revokeObjectURL(tempUrl);

      downloadBtn.href = currentBlobUrl || '#';
      downloadBtn.download = currentFileName;
      downloadBtn.innerText = `‚úÖ Salvo! Clique para Visualizar`;
      setStatus('Arquivo processado e salvo (download iniciado).');
    }

    function resetCamera() {
      if (currentBlobUrl && currentBlobUrl.startsWith('blob:')) {
          URL.revokeObjectURL(currentBlobUrl);
      }
      currentBlobUrl = null;
      currentBlob = null;
      currentFileName = null;

      downloadBtn.href = '#';
      downloadBtn.download = '';
      downloadBtn.innerText = `üì• Baixar / Salvar`;

      // remove possible extra audio link
      const oldAudio = document.getElementById('audioLink');
      if (oldAudio) oldAudio.remove();

      canvasPreview.style.display = 'none';
      videoPreview.style.display = 'none';
      try { videoPreview
