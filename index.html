<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Crispoparte V12 - FINAL (√Åudio + V√≠deo + Moldura)</title>
  <style>
    :root {
      --accent: #25D366;
      --primary: #FF5722;
      --record: #ff0000;
      --bg-overlay: rgba(0, 0, 0, 0.65);
    }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    body { margin: 0; background: #000; color: #fff; overflow: hidden; width: 100vw; height: 100dvh; font-family: sans-serif; }
    .frame { position: relative; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: #000; }
    .stage { position: relative; width: 100%; height: 100%; overflow: hidden; background: #111; }
    video, #molduraPreview, #canvasPreview, #videoPreview { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
    video { transform: scaleX(1); transition: transform 0.3s; }
    video.mirrored { transform: scaleX(-1); }
    #molduraPreview { pointer-events: none; z-index: 5; }
    #canvasPreview, #videoPreview { display: none; z-index: 6; background: #000; }
    .ui-layer { position: absolute; inset: 0; pointer-events: none; z-index: 20; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; }
    .top-bar { display: flex; justify-content: space-between; align-items: flex-start; pointer-events: auto; }
    .timer-badge { background: red; color: white; padding: 5px 12px; border-radius: 12px; font-weight: bold; font-size: 16px; display: none; animation: pulse 1s infinite; }
    @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }
    .controls-bottom { display: flex; flex-direction: column; align-items: center; gap: 15px; pointer-events: auto; padding-bottom: 20px; }
    .mode-switch { display: flex; background: rgba(0,0,0,0.5); border-radius: 20px; padding: 4px; backdrop-filter: blur(4px); }
    .mode-btn { padding: 8px 20px; border-radius: 16px; border: none; background: transparent; color: #ccc; font-weight: 600; cursor: pointer; }
    .mode-btn.active { background: #fff; color: #000; }
    .btn { padding: 10px 16px; font-size: 14px; font-weight: 600; border: 2px solid rgba(255,255,255,0.3); border-radius: 20px; background: var(--bg-overlay); color: #fff; cursor: pointer; backdrop-filter: blur(4px); }
    .btn.active { border-color: var(--accent); background: rgba(37, 211, 102, 0.2); color: var(--accent); }
    .frame-selector { display: flex; gap: 10px; }
    #captureBtn { width: 80px; height: 80px; border-radius: 50%; border: 4px solid #fff; background: rgba(255,255,255,0.2); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
    #captureBtn:active { transform: scale(0.95); }
    #captureBtn svg { width: 36px; height: 36px; fill: #fff; }
    #captureBtn.recording { border-color: var(--record); background: rgba(255, 0, 0, 0.5); }
    #captureBtn.recording svg { fill: var(--record); }
    #captureBtn .stop-icon { display: none; width: 30px; height: 30px; background: var(--record); border-radius: 4px; }
    #captureBtn.recording .stop-icon { display: block; }
    #captureBtn.recording .cam-icon { display: none; }
    #startScreen { position: absolute; inset: 0; background: #000; z-index: 50; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 20px; text-align: center; }
    #startBtn { padding: 18px 32px; font-size: 20px; background: var(--primary); color: white; border: none; border-radius: 50px; cursor: pointer; }
    #postCaptureActions { display: none; flex-direction: column; gap: 12px; width: 100%; max-width: 300px; pointer-events: auto; }
    .action-btn { width: 100%; padding: 14px; border-radius: 12px; border: none; font-size: 16px; font-weight: bold; cursor: pointer; text-align: center; text-decoration: none; display: inline-block; }
    .btn-save { background: var(--accent); color: #fff; }
    .btn-new { background: #555; color: #fff; }
    .flash { position: absolute; inset: 0; background: #fff; opacity: 0; pointer-events: none; z-index: 10; transition: opacity 0.1s; }
    .status { position: absolute; bottom: 18px; left: 18px; z-index: 60; font-size: 13px; color: #ccc; background: rgba(0,0,0,0.4); padding: 6px 10px; border-radius: 10px; pointer-events: none; }
  </style>
</head>
<body>

  <div class="frame">
    <div class="stage" id="stage">
      <video id="camera" autoplay playsinline muted></video>
      <canvas id="canvasPreview"></canvas> 
      <video id="videoPreview" playsinline controls></video>
      <img id="molduraPreview" alt="" src="" />
      <div class="flash" id="flash"></div>

      <div class="ui-layer" id="cameraUI" style="display: none;">
        <div class="top-bar">
          <button class="btn" id="switchBtn">üîÑ Trocar</button>
          <div id="recordingTimer" class="timer-badge">00:00</div>
        </div>

        <div class="controls-bottom">
          <div class="mode-switch">
             <button class="mode-btn active" id="modePhoto">FOTO</button>
             <button class="mode-btn" id="modeVideo">V√çDEO</button>
          </div>

          <div class="frame-selector">
            <button class="btn active" id="m1Btn">1</button>
            <button class="btn" id="m2Btn">2</button>
          </div>

          <button id="captureBtn">
            <svg class="cam-icon" viewBox="0 0 24 24"><path d="M12 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/><path d="M20 5h-3.17L15 3H9L7.17 5H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 14H4V7h16v12z"/></svg>
            <div class="stop-icon"></div>
          </button>
        </div>
      </div>

      <div class="ui-layer" id="resultUI" style="display: none; justify-content: flex-end; align-items: center;">
        <div id="postCaptureActions">
          <a id="downloadBtn" class="action-btn btn-save">üì• Baixar / Salvar</a>
          <button id="shareManualBtn" class="action-btn btn-new">üì± Compartilhar no WhatsApp</button>
        </div>
      </div>

      <div class="status" id="statusMsg">Aguardando</div>
    </div>
  </div>

  <div id="startScreen">
    <h2 style="margin-bottom:0">C√¢mera Crispoparte</h2>
    <p style="color:#aaa; margin-top:5px">Permita c√¢mera e microfone</p>
    <button id="startBtn">INICIAR</button>
    <p id="errorMsg" style="color:red; font-size:12px; margin-top: 10px;"></p>
  </div>

  <canvas id="canvasFinal" style="display: none;"></canvas>

  <script>
    // --- Config ---
    const MERGE_SERVER = ''; // se quiser mesclar no servidor, coloque aqui 'http://IP:4000/merge'
    const MOLDURAS = { 'm1': 'moldura1.png', 'm2': 'moldura2.png' };
    let currentMolduraUrl = MOLDURAS['m1'];
    let currentMolduraImg = new Image(); currentMolduraImg.crossOrigin = "anonymous"; currentMolduraImg.src = currentMolduraUrl;

    let usingFrontCamera = true;
    let stream = null;
    let currentMode = 'photo';
    let isRecording = false;

    let mediaRecorder = null;
    let videoRecorder = null;
    let audioRecorder = null;

    let recordedChunks = [];
    let recordedVideoChunks = [];
    let recordedAudioChunks = [];

    let recordingStartTime = 0;
    let animationFrameId = null;
    let canvasStream = null;

    let finalMimeType = null;
    let finalFileExtension = null;

    let currentBlob = null;
    let currentBlobUrl = null;
    let currentFileName = null;
    let currentFileType = null;

    // --- DOM Elements ---
    const video = document.getElementById('camera');
    const stage = document.getElementById('stage');
    const canvasPreview = document.getElementById('canvasPreview');
    const videoPreview = document.getElementById('videoPreview');
    const molduraPreview = document.getElementById('molduraPreview');
    const canvasFinal = document.getElementById('canvasFinal');
    const ctxFinal = canvasFinal.getContext('2d', { alpha: false });

    const startScreen = document.getElementById('startScreen');
    const cameraUI = document.getElementById('cameraUI');
    const resultUI = document.getElementById('resultUI');
    const captureBtn = document.getElementById('captureBtn');
    const recordingTimer = document.getElementById('recordingTimer');
    const errorMsg = document.getElementById('errorMsg');
    const downloadBtn = document.getElementById('downloadBtn');
    const shareManualBtn = document.getElementById('shareManualBtn');
    const statusMsg = document.getElementById('statusMsg');

    // --- Events ---
    setMoldura(document.getElementById('m1Btn'), 'm1');
    document.getElementById('startBtn').addEventListener('click', () => initCamera(true));
    document.getElementById('switchBtn').addEventListener('click', switchCamera);
    document.getElementById('m1Btn').addEventListener('click', (e) => setMoldura(e.target, 'm1'));
    document.getElementById('m2Btn').addEventListener('click', (e) => setMoldura(e.target, 'm2'));
    document.getElementById('modePhoto').addEventListener('click', () => setMode('photo'));
    document.getElementById('modeVideo').addEventListener('click', () => setMode('video'));

    captureBtn.addEventListener('click', () => {
        if (currentMode === 'photo') takePhoto();
        else { if (!isRecording) startRecording(); else stopRecording(); }
    });

    shareManualBtn.addEventListener('click', showShareInstructions);
    downloadBtn.addEventListener('click', (e) => {
        if (!downloadBtn.href || downloadBtn.href.includes('#')) {
            e.preventDefault();
            alert("Aguarde a finaliza√ß√£o do processamento antes de clicar.");
        }
    });

    function setStatus(s){ statusMsg.innerText = s; }
    function log(...a){ console.log('[crispoparte]', ...a); }

    // --- Moldura / UI ---
    function setMode(mode) {
        currentMode = mode;
        document.getElementById('modePhoto').className = mode === 'photo' ? 'mode-btn active' : 'mode-btn';
        document.getElementById('modeVideo').className = mode === 'video' ? 'mode-btn active' : 'mode-btn';
        captureBtn.style.borderColor = mode === 'video' ? '#ff0000' : '#fff';
    }

    function setMoldura(btn, key) {
      document.querySelectorAll('.frame-selector .btn').forEach(b => b.classList.remove('active'));
      if(btn) btn.classList.add('active');
      currentMolduraUrl = MOLDURAS[key];
      molduraPreview.src = currentMolduraUrl;
      currentMolduraImg = new Image();
      currentMolduraImg.crossOrigin = "anonymous";
      currentMolduraImg.src = currentMolduraUrl;
    }

    // --- Camera init ---
    async function initCamera(tryAudio = true) {
      if (stream) {
        stream.getTracks().forEach(t=>t.stop());
        stream = null;
      }
      setStatus("Solicitando permiss√µes...");
      errorMsg.innerText = "Solicitando permiss√µes...";

      const currentFacingMode = usingFrontCamera ? 'user' : 'environment';
      const constraintsList = [
        { video: { facingMode: currentFacingMode, width: { ideal: 1920 }, height: { ideal: 1080 } } },
        { video: { facingMode: currentFacingMode, width: { ideal: 1280 }, height: { ideal: 720 } } },
        { video: { facingMode: currentFacingMode } }
      ];

      for (const videoConstraints of constraintsList) {
        let constraints = { ...videoConstraints };
        if (tryAudio) constraints.audio = { echoCancellation: true, noiseSuppression: true };

        try {
          stream = await navigator.mediaDevices.getUserMedia(constraints);
          handleStreamSuccess(stream);
          return;
        } catch (err) {
          console.warn('Tentativa falhou com restri√ß√µes:', constraints, 'Erro:', err && err.name);
        }
      }

      if (tryAudio) {
           setStatus("Erro no √°udio. Tentando iniciar sem microfone...");
           errorMsg.innerText = "Erro no √°udio. Tentando iniciar sem microfone...";
           await initCamera(false);
      } else {
           const errMsg = `FALHA CR√çTICA! A c√¢mera e o √°udio n√£o puderam ser inicializados.`;
           errorMsg.innerText = errMsg;
           setStatus(errMsg);
           alert(errMsg);
      }
    }

    function handleStreamSuccess(newStream) {
        stream = newStream;
        video.srcObject = stream;
        if (usingFrontCamera) video.classList.add('mirrored'); else video.classList.remove('mirrored');
        video.onloadedmetadata = () => {
          video.play().catch(()=>{});
          startScreen.style.display = 'none';
          cameraUI.style.display = 'flex';
          setStatus('Pronto');
          errorMsg.innerText = "";
          // ensure canvasFinal is set to unified 1080x1920
          canvasFinal.width = 1080;
          canvasFinal.height = 1920;
        };
    }

    async function switchCamera() {
      if (isRecording) stopRecording();
      usingFrontCamera = !usingFrontCamera;
      await new Promise(resolve => setTimeout(resolve, 600));
      await initCamera(true);
    }

    // --- Photo ---
    async function takePhoto() {
      flashEffect();
      canvasFinal.width = 1080; canvasFinal.height = 1920;
      drawVideoToCanvas(ctxFinal, 1080, 1920);
      await drawImageLayer(ctxFinal, currentMolduraUrl, 1080, 1920);

      const ctxPrev = canvasPreview.getContext('2d');
      canvasPreview.width = stage.clientWidth; canvasPreview.height = stage.clientHeight;
      ctxPrev.drawImage(canvasFinal, 0, 0, canvasPreview.width, canvasPreview.height);

      canvasFinal.toBlob(blob => { showResult('image', blob); }, 'image/png');
    }

    // --- Recording (audio + canvas unified 1080x1920) ---
    async function startRecording() {
        isRecording = true;
        captureBtn.classList.add('recording');
        recordingTimer.style.display = 'block';
        recordingStartTime = Date.now();
        recordedChunks = []; recordedVideoChunks = []; recordedAudioChunks = [];
        finalMimeType = null; finalFileExtension = null;

        canvasFinal.width = 1080; canvasFinal.height = 1920;

        const loop = () => {
            if (!isRecording) return;
            drawVideoToCanvas(ctxFinal, 1080, 1920);
            if (currentMolduraImg && currentMolduraImg.complete) ctxFinal.drawImage(currentMolduraImg, 0, 0, 1080, 1920);
            updateTimer();
            animationFrameId = requestAnimationFrame(loop);
        };
        loop();

        // capture canvas stream (video)
        canvasStream = canvasFinal.captureStream(30);

        // attach audio tracks if available (microphone)
        const audioTracks = stream ? stream.getAudioTracks() : [];
        if (audioTracks && audioTracks.length > 0) {
          try {
            audioTracks.forEach(track => {
              // Some browsers support clone(); otherwise add the original
              try { canvasStream.addTrack(track.clone ? track.clone() : track); }
              catch(e){ try{ canvasStream.addTrack(track); }catch(_){ console.warn('n√£o foi poss√≠vel adicionar track', _); } }
            });
          } catch(e) {
            console.warn('Erro ao anexar audioTracks ao canvasStream', e);
          }
        }

        // prefer webm+opus (broad audio support) then webm/vp8 then mp4 fallback
        const preferred = [
          'video/webm;codecs=vp9,opus',
          'video/webm;codecs=vp8,opus',
          'video/webm;codecs=vp8',
          'video/webm',
          'video/mp4'
        ];
        let chosen = '';
        for (const m of preferred) {
          try { if (m && MediaRecorder.isTypeSupported(m)) { chosen = m; break; } }
          catch(e){}
        }
        finalMimeType = chosen || 'video/webm';
        finalFileExtension = finalMimeType.includes('mp4') ? 'mp4' : 'webm';

        // Try single mixed recorder
        let started = false;
        try {
          mediaRecorder = finalMimeType ? new MediaRecorder(canvasStream, { mimeType: finalMimeType }) : new MediaRecorder(canvasStream);
          mediaRecorder.ondataavailable = e => { if (e.data && e.data.size) recordedChunks.push(e.data); };
          mediaRecorder.onerror = (e) => console.error('mediaRecorder error', e);
          mediaRecorder.onstop = () => finishVideoSingle();
          mediaRecorder.start(1000);
          started = true;
          setStatus('Gravando (single) ...');
        } catch (e) {
          console.warn('Falha ao iniciar MediaRecorder mixed:', e);
          started = false;
        }

        // Fallback: record video and audio separately
        if (!started) {
          setStatus('Fallback: gravando v√≠deo e √°udio separados (merge posterior)');
          try {
            const vmime = preferred.find(m => { try { return MediaRecorder.isTypeSupported(m); } catch(e){ return false; } }) || '';
            videoRecorder = vmime ? new MediaRecorder(canvasStream, { mimeType: vmime }) : new MediaRecorder(canvasStream);
            videoRecorder.ondataavailable = e => { if (e.data && e.data.size) recordedVideoChunks.push(e.data); };

            if (audioTracks && audioTracks.length > 0) {
              // build audio-only stream
              const aStream = new MediaStream(audioTracks.map(t => t.clone ? t.clone() : t));
              let ami = 'audio/webm;codecs=opus';
              try { if (!MediaRecorder.isTypeSupported(ami)) ami = ''; } catch(e){ ami = ''; }
              audioRecorder = ami ? new MediaRecorder(aStream, { mimeType: ami }) : new MediaRecorder(aStream);
              audioRecorder.ondataavailable = e => { if (e.data && e.data.size) recordedAudioChunks.push(e.data); };
            } else {
              audioRecorder = null;
            }

            videoRecorder.onstop = async () => {
              try { if (audioRecorder && audioRecorder.state !== 'inactive') audioRecorder.stop(); } catch(e){}
              await finalizeSeparatedFiles();
            };

            videoRecorder.start(1000);
            if (audioRecorder) audioRecorder.start(1000);
            setStatus('Gravando v√≠deo e √°udio separados...');
          } catch (e) {
            console.error('Erro no fallback recorders', e);
            stopEverythingAfterError();
          }
        }
    }

    function stopRecording() {
      isRecording = false;
      captureBtn.classList.remove('recording');
      cancelAnimationFrame(animationFrameId);
      try { if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop(); } catch(e){}
      try { if (videoRecorder && videoRecorder.state !== 'inactive') videoRecorder.stop(); } catch(e){}
      try { if (audioRecorder && audioRecorder.state !== 'inactive') audioRecorder.stop(); } catch(e){}
      recordingTimer.style.display = 'none';
      recordingTimer.innerText = "00:00";
      setStatus('Processando grava√ß√£o...');
    }

    // Single mixed recorder finished
    function finishVideoSingle() {
      const simpleType = finalMimeType ? finalMimeType.split(';')[0] : 'video/webm';
      const blob = new Blob(recordedChunks, { type: simpleType });
      // basic sanity check
      if (!blob || blob.size < 2000) {
        alert('Erro ao gerar o arquivo de v√≠deo. Tente novamente.');
        resetCamera();
        return;
      }
      const url = URL.createObjectURL(blob);
      videoPreview.src = url;
      videoPreview.style.display = 'block';
      videoPreview.muted = false;
      videoPreview.controls = true;
      try { videoPreview.play().catch(()=>{}); } catch(e){}
      showResult('video', blob, url);
      setStatus('Grava√ß√£o pronta (arquivo √∫nico).');
    }

    // finalize fallback separate files
    async function finalizeSeparatedFiles() {
      const vblob = new Blob(recordedVideoChunks, { type: recordedVideoChunks[0]?.type || 'video/webm' });
      const ablob = recordedAudioChunks.length ? new Blob(recordedAudioChunks, { type: recordedAudioChunks[0]?.type || 'audio/webm' }) : null;

      if (!ablob) {
        // no audio -> provide video only
        const url = URL.createObjectURL(vblob);
        videoPreview.src = url; videoPreview.style.display = 'block'; videoPreview.muted = false; videoPreview.controls = true;
        showResult('video', vblob, url);
        setStatus('Gravado (sem √°udio).');
        return;
      }

      // if MERGE_SERVER configured, upload to server and get MP4 back
      if (MERGE_SERVER && MERGE_SERVER.trim()) {
        setStatus('Enviando ao servidor para mesclar (aguarde)...');
        try {
          const mergedUrl = await uploadAndMergeToServer(vblob, ablob);
          if (mergedUrl) {
            // show merged mp4
            videoPreview.src = mergedUrl; videoPreview.style.display = 'block'; videoPreview.muted = false; videoPreview.controls = true;
            currentBlob = await fetch(mergedUrl).then(r => r.blob());
            currentFileType = 'video';
            currentFileName = `video_${Date.now()}.mp4`;
            currentBlobUrl = mergedUrl;
            downloadBtn.href = currentBlobUrl; downloadBtn.download = currentFileName; downloadBtn.innerText = '‚úÖ Salvo! Clique para Visualizar';
            setStatus('MP4 mesclado pronto.');
            return;
          }
        } catch (e) {
          console.error('uploadAndMergeToServer failed', e);
          // fallback to providing separate files
        }
      }

      // provide separate files to download
      provideSeparateFiles(vblob, ablob);
      setStatus('Arquivos separados prontos (video + audio).');
    }

    function provideSeparateFiles(vblob, ablob) {
      const vurl = URL.createObjectURL(vblob);
      const aurl = ablob ? URL.createObjectURL(ablob) : null;

      downloadBtn.href = vurl;
      downloadBtn.download = `video_${Date.now()}.webm`;
      downloadBtn.innerText = '‚¨áÔ∏è Baixar v√≠deo (webm)';
      downloadBtn.classList.remove('hidden');

      let old = document.getElementById('audioLink');
      if (old) old.remove();
      if (aurl) {
        const aLink = document.createElement('a');
        aLink.id = 'audioLink';
        aLink.href = aurl;
        aLink.download = `audio_${Date.now()}.webm`;
        aLink.textContent = '‚¨áÔ∏è Baixar √°udio (webm)';
        aLink.className = 'action-btn btn-new';
        aLink.style.marginTop = '8px';
        downloadBtn.parentNode.appendChild(aLink);
      }
    }

    function stopEverythingAfterError() {
      isRecording = false;
      captureBtn.classList.remove('recording');
      try { if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop(); } catch(e){}
      try { if (videoRecorder && videoRecorder.state !== 'inactive') videoRecorder.stop(); } catch(e){}
      try { if (audioRecorder && audioRecorder.state !== 'inactive') audioRecorder.stop(); } catch(e){}
      recordingTimer.style.display = 'none';
      recordingTimer.innerText = "00:00";
      setStatus('Erro na grava√ß√£o');
      alert('Erro ao iniciar grava√ß√£o neste navegador. Veja console para detalhes.');
    }

    // upload to server merge (client)
    async function uploadAndMergeToServer(vblob, ablob) {
      try {
        const form = new FormData();
        form.append('video', vblob, 'video.webm');
        if (ablob) form.append('audio', ablob, 'audio.webm');

        const resp = await fetch(MERGE_SERVER, { method: 'POST', body: form });
        if (!resp.ok) throw new Error('Servidor retornou erro: ' + resp.status);
        const resBlob = await resp.blob();
        const url = URL.createObjectURL(resBlob);
        return url;
      } catch (e) {
        console.error('uploadAndMergeToServer error', e);
        throw e;
      }
    }

    // --- Result handling & download ---
    function showResult(type, blob = null, externalUrl = null) {
      video.style.display = 'none'; molduraPreview.style.display = 'none'; cameraUI.style.display = 'none';
      resultUI.style.display = 'flex'; document.getElementById('postCaptureActions').style.display = 'flex';

      const timestamp = Date.now();

      // revoke previously used preview URL only when resetting
      if (currentBlobUrl && currentBlobUrl.startsWith('blob:')) {
          // don't revoke here immediately
      }

      currentBlob = blob;
      currentFileType = type;

      if (type === 'image') {
          canvasPreview.style.display = 'block'; videoPreview.style.display = 'none';
          currentFileName = `foto_${timestamp}.png`;
          currentBlobUrl = externalUrl || URL.createObjectURL(blob);
      } else {
          canvasPreview.style.display = 'none'; videoPreview.style.display = 'block';
          const ext = finalFileExtension || 'webm';
          currentFileName = `video_${timestamp}.${ext}`;
          currentBlobUrl = externalUrl || URL.createObjectURL(blob);
          // set preview src if not already set
          if (!videoPreview.src || videoPreview.src === '') videoPreview.src = currentBlobUrl;
      }

      // Start download (attempt to save to gallery). On Android this should trigger download.
      try {
        const tempUrl = currentBlobUrl;
        const tempLink = document.createElement('a');
        tempLink.style.display = 'none';
        tempLink.href = tempUrl;
        tempLink.download = currentFileName;
        document.body.appendChild(tempLink);
        tempLink.click();
        document.body.removeChild(tempLink);
      } catch (e) {
        console.warn('Download autom√°tico falhou, usu√°rio pode clicar em Baixar.', e);
      }

      // Update download button to preview file (do NOT revoke immediately)
      downloadBtn.href = currentBlobUrl || '#';
      downloadBtn.download = currentFileName;
      downloadBtn.innerText = `‚úÖ Salvo! Clique para Visualizar`;
      setStatus('Arquivo processado. Toque em "Baixar / Salvar" para ver o arquivo.');
    }

    function resetCamera() {
      // revoke previous blob URLs (cleanup)
      if (currentBlobUrl && currentBlobUrl.startsWith('blob:')) {
          try { URL.revokeObjectURL(currentBlobUrl); } catch(e){}
      }
      currentBlobUrl = null;
      currentBlob = null;
      currentFileName = null;

      // remove possible extra audio link
      const oldAudio = document.getElementById('audioLink');
      if (oldAudio) oldAudio.remove();

      downloadBtn.href = '#';
      downloadBtn.download = '';
      downloadBtn.innerText = `üì• Baixar / Salvar`;

      canvasPreview.style.display = 'none';
      videoPreview.style.display = 'none';
      try { videoPreview.pause(); } catch(e){}
      video.style.display = 'block';
      molduraPreview.style.display = 'block';
      resultUI.style.display = 'none';
      cameraUI.style.display = 'flex';
      errorMsg.innerText = "";
      setStatus('Pronto');
    }

    // --- Draw + utils ---
    function updateTimer() {
        const diff = Math.floor((Date.now() - recordingStartTime) / 1000);
        const m = Math.floor(diff / 60).toString().padStart(2,'0');
        const s = (diff % 60).toString().padStart(2,'0');
        recordingTimer.innerText = `${m}:${s}`;
    }

    function drawVideoToCanvas(ctx, w, h) {
      const vw = video.videoWidth; const vh = video.videoHeight;
      if(!vw || !vh) return;
      const vidRatio = vw / vh; const canvasRatio = w / h;
      let dw, dh, dx, dy;
      if (vidRatio > canvasRatio) { dh = h; dw = h * vidRatio; dx = (w - dw) / 2; dy = 0; } 
      else { dw = w; dh = w / vidRatio; dx = 0; dy = (h - dh) / 2; }

      if (usingFrontCamera) {
        ctx.save();
        ctx.scale(-1, 1);
        ctx.drawImage(video, -dx - dw, dy, dw, dh);
        ctx.restore();
      } else {
        ctx.drawImage(video, dx, dy, dw, dh);
      }
    }

    function drawImageLayer(ctx, url, w, h) {
      return new Promise(r => {
        const img = new Image(); img.crossOrigin = "anonymous";
        img.onload = () => { ctx.drawImage(img, 0, 0, w, h); r(); };
        img.onerror = () => r();
        img.src = url;
      });
    }

    function flashEffect() {
        const f = document.getElementById('flash');
        f.style.opacity = '1'; setTimeout(() => f.style.opacity = '0', 150);
    }

    // initialize UI state
    setMoldura(document.getElementById('m1Btn'), 'm1');
    setStatus('Aguardando');
  </script>
</body>
</html>
